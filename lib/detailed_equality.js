// Generated by CoffeeScript 1.9.3
(function() {
  var AssertionError, charm, detailedDifferenceMatcher, difflet, getDifferences, inclusionMatcher, should, unchainedDetailedDifferenceMatcher, unchainedInclusionMatcher, unchainedTester;

  difflet = require('difflet');

  charm = require('charm');

  should = require('should');

  AssertionError = require('assert').AssertionError;

  getDifferences = function(actual, expected) {
    var colorForDifference, constructStream, differenceFound, differenceMap, formatDifferences, resetColor;
    differenceMap = {
      inserted: {
        color: 'green',
        count: 0
      },
      updated: {
        color: 'blue',
        count: 0
      },
      deleted: {
        color: 'red',
        count: 0
      },
      comment: {
        color: 'cyan',
        count: 0
      }
    };
    colorForDifference = (function(_this) {
      return function(type, stream, incrementCounter) {
        if (incrementCounter == null) {
          incrementCounter = true;
        }
        if (_this.c == null) {
          _this.c = charm(stream);
        }
        if (incrementCounter) {
          differenceMap[type].count += 1;
        }
        _this.c.foreground(differenceMap[type].color);
        return _this.c.display('bright');
      };
    })(this);
    resetColor = (function(_this) {
      return function(type, stream) {
        return _this.c.display('reset');
      };
    })(this);
    differenceFound = function() {
      var diff, diffStr, type, val;
      diff = difflet({
        comment: true,
        indent: 2,
        start: colorForDifference,
        stop: resetColor
      });
      diffStr = diff.compare(actual, expected);
      for (type in differenceMap) {
        val = differenceMap[type];
        if (val.count > 0) {
          return diffStr;
        }
      }
      return false;
    };
    constructStream = function() {
      var Stream, stream;
      Stream = require('stream').Stream;
      stream = new Stream;
      stream.readable = true;
      stream.writable = true;
      stream.write = function(buf) {
        return this.emit('data', buf);
      };
      stream.end = function() {
        return this.emit('end');
      };
      return stream;
    };
    formatDifferences = (function(_this) {
      return function(diffString) {
        var differenceSummary;
        if (!diffString) {
          return;
        }
        differenceSummary = function() {
          var str, stream, type, val;
          str = 'Total differences: ';
          stream = constructStream();
          stream.on('data', function(data) {
            return str += data;
          });
          delete _this.c;
          for (type in differenceMap) {
            val = differenceMap[type];
            if (type === 'comment') {
              continue;
            }
            colorForDifference(type, stream, false);
            stream.emit('data', "\t" + type + ": " + val.count + "\t");
            resetColor(type, stream);
          }
          return str;
        };
        return "\n\u001b[0m" + diffString + "\n\n" + (differenceSummary()) + "\n\n";
      };
    })(this);
    return formatDifferences(differenceFound());
  };

  detailedDifferenceMatcher = function(expected) {
    var differences, isOk;
    differences = getDifferences(this.obj, expected);
    isOk = this.negate ? !!differences : !differences;
    this.assert(isOk, (function() {
      console.log(differences);
      return "The Objects differ";
    }), (function() {
      return 'The Objects are identical';
    }));
    return this;
  };

  inclusionMatcher = function(expected) {
    var differences, found, i, len, ref, val;
    found = false;
    ref = this.obj;
    for (i = 0, len = ref.length; i < len; i++) {
      val = ref[i];
      differences = getDifferences(val, expected);
      found = this.negate ? !!differences : !differences;
      if (found) {
        break;
      }
    }
    return this.assert(found, (function() {
      return "The Object was not found";
    }), (function() {
      return 'The Objects was included';
    }));
  };

  unchainedTester = function(equalityTest, negated) {
    return function(expected, actual) {
      if (negated) {
        if ((actual != null) && (expected == null)) {
          return true;
        }
        if ((expected != null) && (actual == null)) {
          return true;
        }
        return actual.should.not[equalityTest](expected);
      } else {
        if (!expected) {
          return should.not.exist(actual);
        }
        should.exist(expected);
        should.exist(actual);
        return actual.should[equalityTest](expected);
      }
    };
  };

  unchainedDetailedDifferenceMatcher = function(negated) {
    if (negated == null) {
      negated = false;
    }
    return unchainedTester('equalObject', negated);
  };

  unchainedInclusionMatcher = function(negated) {
    if (negated == null) {
      negated = false;
    }
    return unchainedTester('includeObject', negated);
  };

  should.Assertion.prototype.equalArray = should.Assertion.prototype.equalObject = should.Assertion.prototype.equalObj = detailedDifferenceMatcher;

  should.Assertion.prototype.includeArray = should.Assertion.prototype.includeObject = should.Assertion.prototype.includeObj = inclusionMatcher;

  should.equalArray = should.equalObj = should.equalObject = unchainedDetailedDifferenceMatcher();

  should.includeArray = should.includeObj = should.includeObject = unchainedInclusionMatcher();

  should.not.equalArray = should.not.equalObj = should.not.equalObject = unchainedDetailedDifferenceMatcher(true);

  should.not.includeArray = should.not.includeObj = should.not.includeObject = unchainedInclusionMatcher(true);

  module.exports = should;

}).call(this);
